//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.9
//
// <auto-generated>
//
// Generated from file `sonar.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __sonar_h__
#define __sonar_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/IncomingAsync.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <Ice/Identity.h>
#include <Ice/BuiltinSequences.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 9
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace sonar
{

class SonarServerListener;
class SonarServerListenerPrx;
class SonarServer;
class SonarServerPrx;

}

namespace sonar
{

enum class Status : unsigned char
{
    OK,
    WARN,
    ERROR
};

using StatusSeq = ::std::vector<Status>;

struct ServerStatus
{
    ::Ice::LongSeq lastReport;
    ::Ice::LongSeq started;
    ::std::string id;
    ::sonar::StatusSeq status;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Ice::LongSeq&, const ::Ice::LongSeq&, const ::std::string&, const ::sonar::StatusSeq&> ice_tuple() const
    {
        return std::tie(lastReport, started, id, status);
    }
};

using ServerStatusSeq = ::std::vector<ServerStatus>;

struct Image
{
    ::sonar::ServerStatusSeq stats;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::sonar::ServerStatusSeq&> ice_tuple() const
    {
        return std::tie(stats);
    }
};

struct Update
{
    ::sonar::ServerStatusSeq updates;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::sonar::ServerStatusSeq&> ice_tuple() const
    {
        return std::tie(updates);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace sonar
{

class SonarServerListener : public virtual ::Ice::Object
{
public:

    using ProxyType = SonarServerListenerPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void onImageAsync(Image img, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_onImage(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void onUpdateAsync(Update upd, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_onUpdate(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void heartbeatAsync(Update upd, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_heartbeat(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void serverUpAsync(::std::string msg, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_serverUp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void serverDownAsync(::std::string msg, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_serverDown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class SonarServer : public virtual ::Ice::Object
{
public:

    using ProxyType = SonarServerPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void onStatusAsync(ServerStatusSeq s, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_onStatus(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void addListenerAsync(::std::shared_ptr<::Ice::Value> listener, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_addListener(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void removeListenerAsync(::std::shared_ptr<::Ice::Value> listener, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_removeListener(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void getStatusesAsync(::std::function<void(const ServerStatusSeq& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getStatuses(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void loadConfigAsync(::std::string fn, ::std::function<void(int returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_loadConfig(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace sonar
{

class SonarServerListenerPrx : public virtual ::Ice::Proxy<SonarServerListenerPrx, ::Ice::ObjectPrx>
{
public:

    void onImage(const Image& img, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &SonarServerListenerPrx::_iceI_onImage, img, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto onImageAsync(const Image& img, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &SonarServerListenerPrx::_iceI_onImage, img, context);
    }

    ::std::function<void()>
    onImageAsync(const Image& img,
                 ::std::function<void()> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &sonar::SonarServerListenerPrx::_iceI_onImage, img, context);
    }

    /// \cond INTERNAL
    void _iceI_onImage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const Image&, const ::Ice::Context&);
    /// \endcond

    void onUpdate(const Update& upd, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &SonarServerListenerPrx::_iceI_onUpdate, upd, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto onUpdateAsync(const Update& upd, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &SonarServerListenerPrx::_iceI_onUpdate, upd, context);
    }

    ::std::function<void()>
    onUpdateAsync(const Update& upd,
                  ::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &sonar::SonarServerListenerPrx::_iceI_onUpdate, upd, context);
    }

    /// \cond INTERNAL
    void _iceI_onUpdate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const Update&, const ::Ice::Context&);
    /// \endcond

    void heartbeat(const Update& upd, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &SonarServerListenerPrx::_iceI_heartbeat, upd, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto heartbeatAsync(const Update& upd, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &SonarServerListenerPrx::_iceI_heartbeat, upd, context);
    }

    ::std::function<void()>
    heartbeatAsync(const Update& upd,
                   ::std::function<void()> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &sonar::SonarServerListenerPrx::_iceI_heartbeat, upd, context);
    }

    /// \cond INTERNAL
    void _iceI_heartbeat(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const Update&, const ::Ice::Context&);
    /// \endcond

    void serverUp(const ::std::string& msg, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &SonarServerListenerPrx::_iceI_serverUp, msg, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto serverUpAsync(const ::std::string& msg, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &SonarServerListenerPrx::_iceI_serverUp, msg, context);
    }

    ::std::function<void()>
    serverUpAsync(const ::std::string& msg,
                  ::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &sonar::SonarServerListenerPrx::_iceI_serverUp, msg, context);
    }

    /// \cond INTERNAL
    void _iceI_serverUp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void serverDown(const ::std::string& msg, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &SonarServerListenerPrx::_iceI_serverDown, msg, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto serverDownAsync(const ::std::string& msg, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &SonarServerListenerPrx::_iceI_serverDown, msg, context);
    }

    ::std::function<void()>
    serverDownAsync(const ::std::string& msg,
                    ::std::function<void()> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &sonar::SonarServerListenerPrx::_iceI_serverDown, msg, context);
    }

    /// \cond INTERNAL
    void _iceI_serverDown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    SonarServerListenerPrx() = default;
    friend ::std::shared_ptr<SonarServerListenerPrx> IceInternal::createProxy<SonarServerListenerPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class SonarServerPrx : public virtual ::Ice::Proxy<SonarServerPrx, ::Ice::ObjectPrx>
{
public:

    void onStatus(const ServerStatusSeq& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &SonarServerPrx::_iceI_onStatus, s, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto onStatusAsync(const ServerStatusSeq& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &SonarServerPrx::_iceI_onStatus, s, context);
    }

    ::std::function<void()>
    onStatusAsync(const ServerStatusSeq& s,
                  ::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &sonar::SonarServerPrx::_iceI_onStatus, s, context);
    }

    /// \cond INTERNAL
    void _iceI_onStatus(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ServerStatusSeq&, const ::Ice::Context&);
    /// \endcond

    void addListener(const ::std::shared_ptr<::Ice::Value>& listener, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &SonarServerPrx::_iceI_addListener, listener, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto addListenerAsync(const ::std::shared_ptr<::Ice::Value>& listener, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &SonarServerPrx::_iceI_addListener, listener, context);
    }

    ::std::function<void()>
    addListenerAsync(const ::std::shared_ptr<::Ice::Value>& listener,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &sonar::SonarServerPrx::_iceI_addListener, listener, context);
    }

    /// \cond INTERNAL
    void _iceI_addListener(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<::Ice::Value>&, const ::Ice::Context&);
    /// \endcond

    void removeListener(const ::std::shared_ptr<::Ice::Value>& listener, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &SonarServerPrx::_iceI_removeListener, listener, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto removeListenerAsync(const ::std::shared_ptr<::Ice::Value>& listener, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &SonarServerPrx::_iceI_removeListener, listener, context);
    }

    ::std::function<void()>
    removeListenerAsync(const ::std::shared_ptr<::Ice::Value>& listener,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &sonar::SonarServerPrx::_iceI_removeListener, listener, context);
    }

    /// \cond INTERNAL
    void _iceI_removeListener(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<::Ice::Value>&, const ::Ice::Context&);
    /// \endcond

    ServerStatusSeq getStatuses(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::sonar::ServerStatusSeq>(true, this, &SonarServerPrx::_iceI_getStatuses, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getStatusesAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::sonar::ServerStatusSeq>>().get_future())
    {
        return _makePromiseOutgoing<::sonar::ServerStatusSeq, P>(false, this, &SonarServerPrx::_iceI_getStatuses, context);
    }

    ::std::function<void()>
    getStatusesAsync(::std::function<void(::sonar::ServerStatusSeq)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::sonar::ServerStatusSeq>(std::move(response), std::move(ex), std::move(sent), this, &sonar::SonarServerPrx::_iceI_getStatuses, context);
    }

    /// \cond INTERNAL
    void _iceI_getStatuses(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::sonar::ServerStatusSeq>>&, const ::Ice::Context&);
    /// \endcond

    int loadConfig(const ::std::string& fn, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &SonarServerPrx::_iceI_loadConfig, fn, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto loadConfigAsync(const ::std::string& fn, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &SonarServerPrx::_iceI_loadConfig, fn, context);
    }

    ::std::function<void()>
    loadConfigAsync(const ::std::string& fn,
                    ::std::function<void(int)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<int>(std::move(response), std::move(ex), std::move(sent), this, &sonar::SonarServerPrx::_iceI_loadConfig, fn, context);
    }

    /// \cond INTERNAL
    void _iceI_loadConfig(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    SonarServerPrx() = default;
    friend ::std::shared_ptr<SonarServerPrx> IceInternal::createProxy<SonarServerPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::sonar::Status>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::sonar::ServerStatus>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::sonar::ServerStatus, S>
{
    static void read(S* istr, ::sonar::ServerStatus& v)
    {
        istr->readAll(v.lastReport, v.started, v.id, v.status);
    }
};

template<>
struct StreamableTraits<::sonar::Image>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::sonar::Image, S>
{
    static void read(S* istr, ::sonar::Image& v)
    {
        istr->readAll(v.stats);
    }
};

template<>
struct StreamableTraits<::sonar::Update>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::sonar::Update, S>
{
    static void read(S* istr, ::sonar::Update& v)
    {
        istr->readAll(v.updates);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace sonar
{

using SonarServerListenerPtr = ::std::shared_ptr<SonarServerListener>;
using SonarServerListenerPrxPtr = ::std::shared_ptr<SonarServerListenerPrx>;

using SonarServerPtr = ::std::shared_ptr<SonarServer>;
using SonarServerPrxPtr = ::std::shared_ptr<SonarServerPrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace sonar
{

class SonarServerListener;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< SonarServerListener>&);
::IceProxy::Ice::Object* upCast(SonarServerListener*);
/// \endcond

class SonarServer;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< SonarServer>&);
::IceProxy::Ice::Object* upCast(SonarServer*);
/// \endcond

}

}

namespace sonar
{

class SonarServerListener;
/// \cond INTERNAL
::Ice::Object* upCast(SonarServerListener*);
/// \endcond
typedef ::IceInternal::Handle< SonarServerListener> SonarServerListenerPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::sonar::SonarServerListener> SonarServerListenerPrx;
typedef SonarServerListenerPrx SonarServerListenerPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(SonarServerListenerPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class SonarServer;
/// \cond INTERNAL
::Ice::Object* upCast(SonarServer*);
/// \endcond
typedef ::IceInternal::Handle< SonarServer> SonarServerPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::sonar::SonarServer> SonarServerPrx;
typedef SonarServerPrx SonarServerPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(SonarServerPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace sonar
{

enum Status
{
    OK,
    WARN,
    ERROR
};

typedef ::std::vector<Status> StatusSeq;

struct ServerStatus
{
    ::Ice::LongSeq lastReport;
    ::Ice::LongSeq started;
    ::std::string id;
    ::sonar::StatusSeq status;
};

typedef ::std::vector<ServerStatus> ServerStatusSeq;

struct Image
{
    ::sonar::ServerStatusSeq stats;
};

struct Update
{
    ::sonar::ServerStatusSeq updates;
};

}

namespace sonar
{

/**
 * AMD callback class for sonar::SonarServerListener::onImage_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_SonarServerListener_onImage : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_SonarServerListener_onImage();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::sonar::AMD_SonarServerListener_onImage> AMD_SonarServerListener_onImagePtr;

/**
 * AMD callback class for sonar::SonarServerListener::onUpdate_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_SonarServerListener_onUpdate : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_SonarServerListener_onUpdate();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::sonar::AMD_SonarServerListener_onUpdate> AMD_SonarServerListener_onUpdatePtr;

/**
 * AMD callback class for sonar::SonarServerListener::heartbeat_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_SonarServerListener_heartbeat : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_SonarServerListener_heartbeat();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::sonar::AMD_SonarServerListener_heartbeat> AMD_SonarServerListener_heartbeatPtr;

/**
 * AMD callback class for sonar::SonarServerListener::serverUp_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_SonarServerListener_serverUp : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_SonarServerListener_serverUp();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::sonar::AMD_SonarServerListener_serverUp> AMD_SonarServerListener_serverUpPtr;

/**
 * AMD callback class for sonar::SonarServerListener::serverDown_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_SonarServerListener_serverDown : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_SonarServerListener_serverDown();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::sonar::AMD_SonarServerListener_serverDown> AMD_SonarServerListener_serverDownPtr;

/**
 * AMD callback class for sonar::SonarServer::onStatus_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_SonarServer_onStatus : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_SonarServer_onStatus();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::sonar::AMD_SonarServer_onStatus> AMD_SonarServer_onStatusPtr;

/**
 * AMD callback class for sonar::SonarServer::addListener_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_SonarServer_addListener : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_SonarServer_addListener();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::sonar::AMD_SonarServer_addListener> AMD_SonarServer_addListenerPtr;

/**
 * AMD callback class for sonar::SonarServer::removeListener_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_SonarServer_removeListener : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_SonarServer_removeListener();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::sonar::AMD_SonarServer_removeListener> AMD_SonarServer_removeListenerPtr;

/**
 * AMD callback class for sonar::SonarServer::getStatuses_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_SonarServer_getStatuses : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_SonarServer_getStatuses();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const ServerStatusSeq& result) = 0;
};

typedef ::IceUtil::Handle< ::sonar::AMD_SonarServer_getStatuses> AMD_SonarServer_getStatusesPtr;

/**
 * AMD callback class for sonar::SonarServer::loadConfig_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_SonarServer_loadConfig : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_SonarServer_loadConfig();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(::Ice::Int result) = 0;
};

typedef ::IceUtil::Handle< ::sonar::AMD_SonarServer_loadConfig> AMD_SonarServer_loadConfigPtr;

}

/// \cond INTERNAL
namespace IceAsync
{

namespace sonar
{

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_SonarServerListener_onImage : public ::sonar::AMD_SonarServerListener_onImage, public ::IceInternal::IncomingAsync
{
public:

    AMD_SonarServerListener_onImage(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_SonarServerListener_onUpdate : public ::sonar::AMD_SonarServerListener_onUpdate, public ::IceInternal::IncomingAsync
{
public:

    AMD_SonarServerListener_onUpdate(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_SonarServerListener_heartbeat : public ::sonar::AMD_SonarServerListener_heartbeat, public ::IceInternal::IncomingAsync
{
public:

    AMD_SonarServerListener_heartbeat(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_SonarServerListener_serverUp : public ::sonar::AMD_SonarServerListener_serverUp, public ::IceInternal::IncomingAsync
{
public:

    AMD_SonarServerListener_serverUp(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_SonarServerListener_serverDown : public ::sonar::AMD_SonarServerListener_serverDown, public ::IceInternal::IncomingAsync
{
public:

    AMD_SonarServerListener_serverDown(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_SonarServer_onStatus : public ::sonar::AMD_SonarServer_onStatus, public ::IceInternal::IncomingAsync
{
public:

    AMD_SonarServer_onStatus(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_SonarServer_addListener : public ::sonar::AMD_SonarServer_addListener, public ::IceInternal::IncomingAsync
{
public:

    AMD_SonarServer_addListener(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_SonarServer_removeListener : public ::sonar::AMD_SonarServer_removeListener, public ::IceInternal::IncomingAsync
{
public:

    AMD_SonarServer_removeListener(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_SonarServer_getStatuses : public ::sonar::AMD_SonarServer_getStatuses, public ::IceInternal::IncomingAsync
{
public:

    AMD_SonarServer_getStatuses(::IceInternal::Incoming&);

    virtual void ice_response(const ::sonar::ServerStatusSeq&);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_SonarServer_loadConfig : public ::sonar::AMD_SonarServer_loadConfig, public ::IceInternal::IncomingAsync
{
public:

    AMD_SonarServer_loadConfig(::IceInternal::Incoming&);

    virtual void ice_response(::Ice::Int);
};

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

}

}
/// \endcond

namespace sonar
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::sonar::SonarServerListener::begin_onImage.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServerListener_onImage.
 */
class Callback_SonarServerListener_onImage_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SonarServerListener_onImage_Base> Callback_SonarServerListener_onImagePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::sonar::SonarServerListener::begin_onUpdate.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServerListener_onUpdate.
 */
class Callback_SonarServerListener_onUpdate_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SonarServerListener_onUpdate_Base> Callback_SonarServerListener_onUpdatePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::sonar::SonarServerListener::begin_heartbeat.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServerListener_heartbeat.
 */
class Callback_SonarServerListener_heartbeat_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SonarServerListener_heartbeat_Base> Callback_SonarServerListener_heartbeatPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::sonar::SonarServerListener::begin_serverUp.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServerListener_serverUp.
 */
class Callback_SonarServerListener_serverUp_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SonarServerListener_serverUp_Base> Callback_SonarServerListener_serverUpPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::sonar::SonarServerListener::begin_serverDown.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServerListener_serverDown.
 */
class Callback_SonarServerListener_serverDown_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SonarServerListener_serverDown_Base> Callback_SonarServerListener_serverDownPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::sonar::SonarServer::begin_onStatus.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServer_onStatus.
 */
class Callback_SonarServer_onStatus_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SonarServer_onStatus_Base> Callback_SonarServer_onStatusPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::sonar::SonarServer::begin_addListener.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServer_addListener.
 */
class Callback_SonarServer_addListener_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SonarServer_addListener_Base> Callback_SonarServer_addListenerPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::sonar::SonarServer::begin_removeListener.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServer_removeListener.
 */
class Callback_SonarServer_removeListener_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SonarServer_removeListener_Base> Callback_SonarServer_removeListenerPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::sonar::SonarServer::begin_getStatuses.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServer_getStatuses.
 */
class Callback_SonarServer_getStatuses_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SonarServer_getStatuses_Base> Callback_SonarServer_getStatusesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::sonar::SonarServer::begin_loadConfig.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServer_loadConfig.
 */
class Callback_SonarServer_loadConfig_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SonarServer_loadConfig_Base> Callback_SonarServer_loadConfigPtr;

}

namespace IceProxy
{

namespace sonar
{

class SonarServerListener : public virtual ::Ice::Proxy<SonarServerListener, ::IceProxy::Ice::Object>
{
public:

    void onImage(const ::sonar::Image& img, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_onImage(_iceI_begin_onImage(img, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_onImage(const ::sonar::Image& img, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_onImage(img, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onImage(const ::sonar::Image& img, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onImage(img, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_onImage(const ::sonar::Image& img, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onImage(img, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_onImage(const ::sonar::Image& img, const ::sonar::Callback_SonarServerListener_onImagePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onImage(img, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_onImage(const ::sonar::Image& img, const ::Ice::Context& context, const ::sonar::Callback_SonarServerListener_onImagePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onImage(img, context, cb, cookie);
    }

    void end_onImage(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_onImage(const ::sonar::Image&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void onUpdate(const ::sonar::Update& upd, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_onUpdate(_iceI_begin_onUpdate(upd, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_onUpdate(const ::sonar::Update& upd, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_onUpdate(upd, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onUpdate(const ::sonar::Update& upd, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onUpdate(upd, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_onUpdate(const ::sonar::Update& upd, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onUpdate(upd, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_onUpdate(const ::sonar::Update& upd, const ::sonar::Callback_SonarServerListener_onUpdatePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onUpdate(upd, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_onUpdate(const ::sonar::Update& upd, const ::Ice::Context& context, const ::sonar::Callback_SonarServerListener_onUpdatePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onUpdate(upd, context, cb, cookie);
    }

    void end_onUpdate(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_onUpdate(const ::sonar::Update&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void heartbeat(const ::sonar::Update& upd, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_heartbeat(_iceI_begin_heartbeat(upd, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_heartbeat(const ::sonar::Update& upd, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_heartbeat(upd, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_heartbeat(const ::sonar::Update& upd, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_heartbeat(upd, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_heartbeat(const ::sonar::Update& upd, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_heartbeat(upd, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_heartbeat(const ::sonar::Update& upd, const ::sonar::Callback_SonarServerListener_heartbeatPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_heartbeat(upd, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_heartbeat(const ::sonar::Update& upd, const ::Ice::Context& context, const ::sonar::Callback_SonarServerListener_heartbeatPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_heartbeat(upd, context, cb, cookie);
    }

    void end_heartbeat(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_heartbeat(const ::sonar::Update&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void serverUp(const ::std::string& msg, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_serverUp(_iceI_begin_serverUp(msg, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_serverUp(const ::std::string& msg, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_serverUp(msg, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_serverUp(const ::std::string& msg, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_serverUp(msg, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_serverUp(const ::std::string& msg, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_serverUp(msg, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_serverUp(const ::std::string& msg, const ::sonar::Callback_SonarServerListener_serverUpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_serverUp(msg, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_serverUp(const ::std::string& msg, const ::Ice::Context& context, const ::sonar::Callback_SonarServerListener_serverUpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_serverUp(msg, context, cb, cookie);
    }

    void end_serverUp(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_serverUp(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void serverDown(const ::std::string& msg, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_serverDown(_iceI_begin_serverDown(msg, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_serverDown(const ::std::string& msg, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_serverDown(msg, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_serverDown(const ::std::string& msg, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_serverDown(msg, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_serverDown(const ::std::string& msg, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_serverDown(msg, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_serverDown(const ::std::string& msg, const ::sonar::Callback_SonarServerListener_serverDownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_serverDown(msg, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_serverDown(const ::std::string& msg, const ::Ice::Context& context, const ::sonar::Callback_SonarServerListener_serverDownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_serverDown(msg, context, cb, cookie);
    }

    void end_serverDown(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_serverDown(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class SonarServer : public virtual ::Ice::Proxy<SonarServer, ::IceProxy::Ice::Object>
{
public:

    void onStatus(const ::sonar::ServerStatusSeq& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_onStatus(_iceI_begin_onStatus(s, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_onStatus(const ::sonar::ServerStatusSeq& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_onStatus(s, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onStatus(const ::sonar::ServerStatusSeq& s, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onStatus(s, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_onStatus(const ::sonar::ServerStatusSeq& s, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onStatus(s, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_onStatus(const ::sonar::ServerStatusSeq& s, const ::sonar::Callback_SonarServer_onStatusPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onStatus(s, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_onStatus(const ::sonar::ServerStatusSeq& s, const ::Ice::Context& context, const ::sonar::Callback_SonarServer_onStatusPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onStatus(s, context, cb, cookie);
    }

    void end_onStatus(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_onStatus(const ::sonar::ServerStatusSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void addListener(const ::sonar::SonarServerListenerPtr& listener, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_addListener(_iceI_begin_addListener(listener, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_addListener(const ::sonar::SonarServerListenerPtr& listener, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_addListener(listener, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addListener(const ::sonar::SonarServerListenerPtr& listener, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addListener(listener, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addListener(const ::sonar::SonarServerListenerPtr& listener, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addListener(listener, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addListener(const ::sonar::SonarServerListenerPtr& listener, const ::sonar::Callback_SonarServer_addListenerPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addListener(listener, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addListener(const ::sonar::SonarServerListenerPtr& listener, const ::Ice::Context& context, const ::sonar::Callback_SonarServer_addListenerPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addListener(listener, context, cb, cookie);
    }

    void end_addListener(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_addListener(const ::sonar::SonarServerListenerPtr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void removeListener(const ::sonar::SonarServerListenerPtr& listener, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_removeListener(_iceI_begin_removeListener(listener, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_removeListener(const ::sonar::SonarServerListenerPtr& listener, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_removeListener(listener, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeListener(const ::sonar::SonarServerListenerPtr& listener, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeListener(listener, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeListener(const ::sonar::SonarServerListenerPtr& listener, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeListener(listener, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeListener(const ::sonar::SonarServerListenerPtr& listener, const ::sonar::Callback_SonarServer_removeListenerPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeListener(listener, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeListener(const ::sonar::SonarServerListenerPtr& listener, const ::Ice::Context& context, const ::sonar::Callback_SonarServer_removeListenerPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeListener(listener, context, cb, cookie);
    }

    void end_removeListener(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_removeListener(const ::sonar::SonarServerListenerPtr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::sonar::ServerStatusSeq getStatuses(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getStatuses(_iceI_begin_getStatuses(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getStatuses(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getStatuses(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStatuses(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStatuses(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStatuses(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStatuses(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStatuses(const ::sonar::Callback_SonarServer_getStatusesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStatuses(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStatuses(const ::Ice::Context& context, const ::sonar::Callback_SonarServer_getStatusesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStatuses(context, cb, cookie);
    }

    ::sonar::ServerStatusSeq end_getStatuses(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getStatuses(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Int loadConfig(const ::std::string& fn, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_loadConfig(_iceI_begin_loadConfig(fn, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_loadConfig(const ::std::string& fn, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_loadConfig(fn, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_loadConfig(const ::std::string& fn, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_loadConfig(fn, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_loadConfig(const ::std::string& fn, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_loadConfig(fn, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_loadConfig(const ::std::string& fn, const ::sonar::Callback_SonarServer_loadConfigPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_loadConfig(fn, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_loadConfig(const ::std::string& fn, const ::Ice::Context& context, const ::sonar::Callback_SonarServer_loadConfigPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_loadConfig(fn, context, cb, cookie);
    }

    ::Ice::Int end_loadConfig(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_loadConfig(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace sonar
{

class SonarServerListener : public virtual ::Ice::Object
{
public:

    typedef SonarServerListenerPrx ProxyType;
    typedef SonarServerListenerPtr PointerType;

    virtual ~SonarServerListener();

#ifdef ICE_CPP11_COMPILER
    SonarServerListener() = default;
    SonarServerListener(const SonarServerListener&) = default;
    SonarServerListener& operator=(const SonarServerListener&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void onImage_async(const ::sonar::AMD_SonarServerListener_onImagePtr& cb, const Image& img, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_onImage(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void onUpdate_async(const ::sonar::AMD_SonarServerListener_onUpdatePtr& cb, const Update& upd, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_onUpdate(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void heartbeat_async(const ::sonar::AMD_SonarServerListener_heartbeatPtr& cb, const Update& upd, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_heartbeat(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void serverUp_async(const ::sonar::AMD_SonarServerListener_serverUpPtr& cb, const ::std::string& msg, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_serverUp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void serverDown_async(const ::sonar::AMD_SonarServerListener_serverDownPtr& cb, const ::std::string& msg, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_serverDown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const SonarServerListener& lhs, const SonarServerListener& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const SonarServerListener& lhs, const SonarServerListener& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class SonarServer : public virtual ::Ice::Object
{
public:

    typedef SonarServerPrx ProxyType;
    typedef SonarServerPtr PointerType;

    virtual ~SonarServer();

#ifdef ICE_CPP11_COMPILER
    SonarServer() = default;
    SonarServer(const SonarServer&) = default;
    SonarServer& operator=(const SonarServer&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void onStatus_async(const ::sonar::AMD_SonarServer_onStatusPtr& cb, const ServerStatusSeq& s, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_onStatus(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void addListener_async(const ::sonar::AMD_SonarServer_addListenerPtr& cb, const SonarServerListenerPtr& listener, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_addListener(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void removeListener_async(const ::sonar::AMD_SonarServer_removeListenerPtr& cb, const SonarServerListenerPtr& listener, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_removeListener(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void getStatuses_async(const ::sonar::AMD_SonarServer_getStatusesPtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getStatuses(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void loadConfig_async(const ::sonar::AMD_SonarServer_loadConfigPtr& cb, const ::std::string& fn, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_loadConfig(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const SonarServer& lhs, const SonarServer& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const SonarServer& lhs, const SonarServer& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::sonar::Status>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::sonar::ServerStatus>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::sonar::ServerStatus, S>
{
    static void write(S* ostr, const ::sonar::ServerStatus& v)
    {
        ostr->write(v.lastReport);
        ostr->write(v.started);
        ostr->write(v.id);
        ostr->write(v.status);
    }
};

template<typename S>
struct StreamReader< ::sonar::ServerStatus, S>
{
    static void read(S* istr, ::sonar::ServerStatus& v)
    {
        istr->read(v.lastReport);
        istr->read(v.started);
        istr->read(v.id);
        istr->read(v.status);
    }
};

template<>
struct StreamableTraits< ::sonar::Image>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::sonar::Image, S>
{
    static void write(S* ostr, const ::sonar::Image& v)
    {
        ostr->write(v.stats);
    }
};

template<typename S>
struct StreamReader< ::sonar::Image, S>
{
    static void read(S* istr, ::sonar::Image& v)
    {
        istr->read(v.stats);
    }
};

template<>
struct StreamableTraits< ::sonar::Update>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::sonar::Update, S>
{
    static void write(S* ostr, const ::sonar::Update& v)
    {
        ostr->write(v.updates);
    }
};

template<typename S>
struct StreamReader< ::sonar::Update, S>
{
    static void read(S* istr, ::sonar::Update& v)
    {
        istr->read(v.updates);
    }
};

}
/// \endcond

namespace sonar
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::sonar::SonarServerListener::begin_onImage.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServerListener_onImage.
 */
template<class T>
class CallbackNC_SonarServerListener_onImage : public Callback_SonarServerListener_onImage_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_SonarServerListener_onImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_onImage.
 */
template<class T> Callback_SonarServerListener_onImagePtr
newCallback_SonarServerListener_onImage(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServerListener_onImage<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_onImage.
 */
template<class T> Callback_SonarServerListener_onImagePtr
newCallback_SonarServerListener_onImage(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServerListener_onImage<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_onImage.
 */
template<class T> Callback_SonarServerListener_onImagePtr
newCallback_SonarServerListener_onImage(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServerListener_onImage<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_onImage.
 */
template<class T> Callback_SonarServerListener_onImagePtr
newCallback_SonarServerListener_onImage(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServerListener_onImage<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::sonar::SonarServerListener::begin_onImage.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServerListener_onImage.
 */
template<class T, typename CT>
class Callback_SonarServerListener_onImage : public Callback_SonarServerListener_onImage_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_SonarServerListener_onImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_onImage.
 */
template<class T, typename CT> Callback_SonarServerListener_onImagePtr
newCallback_SonarServerListener_onImage(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServerListener_onImage<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_onImage.
 */
template<class T, typename CT> Callback_SonarServerListener_onImagePtr
newCallback_SonarServerListener_onImage(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServerListener_onImage<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_onImage.
 */
template<class T, typename CT> Callback_SonarServerListener_onImagePtr
newCallback_SonarServerListener_onImage(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServerListener_onImage<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_onImage.
 */
template<class T, typename CT> Callback_SonarServerListener_onImagePtr
newCallback_SonarServerListener_onImage(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServerListener_onImage<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::sonar::SonarServerListener::begin_onUpdate.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServerListener_onUpdate.
 */
template<class T>
class CallbackNC_SonarServerListener_onUpdate : public Callback_SonarServerListener_onUpdate_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_SonarServerListener_onUpdate(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_onUpdate.
 */
template<class T> Callback_SonarServerListener_onUpdatePtr
newCallback_SonarServerListener_onUpdate(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServerListener_onUpdate<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_onUpdate.
 */
template<class T> Callback_SonarServerListener_onUpdatePtr
newCallback_SonarServerListener_onUpdate(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServerListener_onUpdate<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_onUpdate.
 */
template<class T> Callback_SonarServerListener_onUpdatePtr
newCallback_SonarServerListener_onUpdate(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServerListener_onUpdate<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_onUpdate.
 */
template<class T> Callback_SonarServerListener_onUpdatePtr
newCallback_SonarServerListener_onUpdate(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServerListener_onUpdate<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::sonar::SonarServerListener::begin_onUpdate.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServerListener_onUpdate.
 */
template<class T, typename CT>
class Callback_SonarServerListener_onUpdate : public Callback_SonarServerListener_onUpdate_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_SonarServerListener_onUpdate(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_onUpdate.
 */
template<class T, typename CT> Callback_SonarServerListener_onUpdatePtr
newCallback_SonarServerListener_onUpdate(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServerListener_onUpdate<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_onUpdate.
 */
template<class T, typename CT> Callback_SonarServerListener_onUpdatePtr
newCallback_SonarServerListener_onUpdate(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServerListener_onUpdate<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_onUpdate.
 */
template<class T, typename CT> Callback_SonarServerListener_onUpdatePtr
newCallback_SonarServerListener_onUpdate(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServerListener_onUpdate<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_onUpdate.
 */
template<class T, typename CT> Callback_SonarServerListener_onUpdatePtr
newCallback_SonarServerListener_onUpdate(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServerListener_onUpdate<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::sonar::SonarServerListener::begin_heartbeat.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServerListener_heartbeat.
 */
template<class T>
class CallbackNC_SonarServerListener_heartbeat : public Callback_SonarServerListener_heartbeat_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_SonarServerListener_heartbeat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_heartbeat.
 */
template<class T> Callback_SonarServerListener_heartbeatPtr
newCallback_SonarServerListener_heartbeat(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServerListener_heartbeat<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_heartbeat.
 */
template<class T> Callback_SonarServerListener_heartbeatPtr
newCallback_SonarServerListener_heartbeat(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServerListener_heartbeat<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_heartbeat.
 */
template<class T> Callback_SonarServerListener_heartbeatPtr
newCallback_SonarServerListener_heartbeat(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServerListener_heartbeat<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_heartbeat.
 */
template<class T> Callback_SonarServerListener_heartbeatPtr
newCallback_SonarServerListener_heartbeat(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServerListener_heartbeat<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::sonar::SonarServerListener::begin_heartbeat.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServerListener_heartbeat.
 */
template<class T, typename CT>
class Callback_SonarServerListener_heartbeat : public Callback_SonarServerListener_heartbeat_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_SonarServerListener_heartbeat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_heartbeat.
 */
template<class T, typename CT> Callback_SonarServerListener_heartbeatPtr
newCallback_SonarServerListener_heartbeat(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServerListener_heartbeat<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_heartbeat.
 */
template<class T, typename CT> Callback_SonarServerListener_heartbeatPtr
newCallback_SonarServerListener_heartbeat(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServerListener_heartbeat<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_heartbeat.
 */
template<class T, typename CT> Callback_SonarServerListener_heartbeatPtr
newCallback_SonarServerListener_heartbeat(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServerListener_heartbeat<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_heartbeat.
 */
template<class T, typename CT> Callback_SonarServerListener_heartbeatPtr
newCallback_SonarServerListener_heartbeat(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServerListener_heartbeat<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::sonar::SonarServerListener::begin_serverUp.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServerListener_serverUp.
 */
template<class T>
class CallbackNC_SonarServerListener_serverUp : public Callback_SonarServerListener_serverUp_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_SonarServerListener_serverUp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_serverUp.
 */
template<class T> Callback_SonarServerListener_serverUpPtr
newCallback_SonarServerListener_serverUp(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServerListener_serverUp<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_serverUp.
 */
template<class T> Callback_SonarServerListener_serverUpPtr
newCallback_SonarServerListener_serverUp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServerListener_serverUp<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_serverUp.
 */
template<class T> Callback_SonarServerListener_serverUpPtr
newCallback_SonarServerListener_serverUp(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServerListener_serverUp<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_serverUp.
 */
template<class T> Callback_SonarServerListener_serverUpPtr
newCallback_SonarServerListener_serverUp(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServerListener_serverUp<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::sonar::SonarServerListener::begin_serverUp.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServerListener_serverUp.
 */
template<class T, typename CT>
class Callback_SonarServerListener_serverUp : public Callback_SonarServerListener_serverUp_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_SonarServerListener_serverUp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_serverUp.
 */
template<class T, typename CT> Callback_SonarServerListener_serverUpPtr
newCallback_SonarServerListener_serverUp(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServerListener_serverUp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_serverUp.
 */
template<class T, typename CT> Callback_SonarServerListener_serverUpPtr
newCallback_SonarServerListener_serverUp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServerListener_serverUp<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_serverUp.
 */
template<class T, typename CT> Callback_SonarServerListener_serverUpPtr
newCallback_SonarServerListener_serverUp(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServerListener_serverUp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_serverUp.
 */
template<class T, typename CT> Callback_SonarServerListener_serverUpPtr
newCallback_SonarServerListener_serverUp(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServerListener_serverUp<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::sonar::SonarServerListener::begin_serverDown.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServerListener_serverDown.
 */
template<class T>
class CallbackNC_SonarServerListener_serverDown : public Callback_SonarServerListener_serverDown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_SonarServerListener_serverDown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_serverDown.
 */
template<class T> Callback_SonarServerListener_serverDownPtr
newCallback_SonarServerListener_serverDown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServerListener_serverDown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_serverDown.
 */
template<class T> Callback_SonarServerListener_serverDownPtr
newCallback_SonarServerListener_serverDown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServerListener_serverDown<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_serverDown.
 */
template<class T> Callback_SonarServerListener_serverDownPtr
newCallback_SonarServerListener_serverDown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServerListener_serverDown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_serverDown.
 */
template<class T> Callback_SonarServerListener_serverDownPtr
newCallback_SonarServerListener_serverDown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServerListener_serverDown<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::sonar::SonarServerListener::begin_serverDown.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServerListener_serverDown.
 */
template<class T, typename CT>
class Callback_SonarServerListener_serverDown : public Callback_SonarServerListener_serverDown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_SonarServerListener_serverDown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_serverDown.
 */
template<class T, typename CT> Callback_SonarServerListener_serverDownPtr
newCallback_SonarServerListener_serverDown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServerListener_serverDown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_serverDown.
 */
template<class T, typename CT> Callback_SonarServerListener_serverDownPtr
newCallback_SonarServerListener_serverDown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServerListener_serverDown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_serverDown.
 */
template<class T, typename CT> Callback_SonarServerListener_serverDownPtr
newCallback_SonarServerListener_serverDown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServerListener_serverDown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServerListener::begin_serverDown.
 */
template<class T, typename CT> Callback_SonarServerListener_serverDownPtr
newCallback_SonarServerListener_serverDown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServerListener_serverDown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::sonar::SonarServer::begin_onStatus.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServer_onStatus.
 */
template<class T>
class CallbackNC_SonarServer_onStatus : public Callback_SonarServer_onStatus_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_SonarServer_onStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_onStatus.
 */
template<class T> Callback_SonarServer_onStatusPtr
newCallback_SonarServer_onStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServer_onStatus<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_onStatus.
 */
template<class T> Callback_SonarServer_onStatusPtr
newCallback_SonarServer_onStatus(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServer_onStatus<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_onStatus.
 */
template<class T> Callback_SonarServer_onStatusPtr
newCallback_SonarServer_onStatus(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServer_onStatus<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_onStatus.
 */
template<class T> Callback_SonarServer_onStatusPtr
newCallback_SonarServer_onStatus(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServer_onStatus<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::sonar::SonarServer::begin_onStatus.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServer_onStatus.
 */
template<class T, typename CT>
class Callback_SonarServer_onStatus : public Callback_SonarServer_onStatus_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_SonarServer_onStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_onStatus.
 */
template<class T, typename CT> Callback_SonarServer_onStatusPtr
newCallback_SonarServer_onStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServer_onStatus<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_onStatus.
 */
template<class T, typename CT> Callback_SonarServer_onStatusPtr
newCallback_SonarServer_onStatus(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServer_onStatus<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_onStatus.
 */
template<class T, typename CT> Callback_SonarServer_onStatusPtr
newCallback_SonarServer_onStatus(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServer_onStatus<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_onStatus.
 */
template<class T, typename CT> Callback_SonarServer_onStatusPtr
newCallback_SonarServer_onStatus(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServer_onStatus<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::sonar::SonarServer::begin_addListener.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServer_addListener.
 */
template<class T>
class CallbackNC_SonarServer_addListener : public Callback_SonarServer_addListener_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_SonarServer_addListener(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_addListener.
 */
template<class T> Callback_SonarServer_addListenerPtr
newCallback_SonarServer_addListener(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServer_addListener<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_addListener.
 */
template<class T> Callback_SonarServer_addListenerPtr
newCallback_SonarServer_addListener(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServer_addListener<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_addListener.
 */
template<class T> Callback_SonarServer_addListenerPtr
newCallback_SonarServer_addListener(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServer_addListener<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_addListener.
 */
template<class T> Callback_SonarServer_addListenerPtr
newCallback_SonarServer_addListener(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServer_addListener<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::sonar::SonarServer::begin_addListener.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServer_addListener.
 */
template<class T, typename CT>
class Callback_SonarServer_addListener : public Callback_SonarServer_addListener_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_SonarServer_addListener(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_addListener.
 */
template<class T, typename CT> Callback_SonarServer_addListenerPtr
newCallback_SonarServer_addListener(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServer_addListener<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_addListener.
 */
template<class T, typename CT> Callback_SonarServer_addListenerPtr
newCallback_SonarServer_addListener(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServer_addListener<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_addListener.
 */
template<class T, typename CT> Callback_SonarServer_addListenerPtr
newCallback_SonarServer_addListener(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServer_addListener<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_addListener.
 */
template<class T, typename CT> Callback_SonarServer_addListenerPtr
newCallback_SonarServer_addListener(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServer_addListener<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::sonar::SonarServer::begin_removeListener.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServer_removeListener.
 */
template<class T>
class CallbackNC_SonarServer_removeListener : public Callback_SonarServer_removeListener_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_SonarServer_removeListener(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_removeListener.
 */
template<class T> Callback_SonarServer_removeListenerPtr
newCallback_SonarServer_removeListener(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServer_removeListener<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_removeListener.
 */
template<class T> Callback_SonarServer_removeListenerPtr
newCallback_SonarServer_removeListener(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServer_removeListener<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_removeListener.
 */
template<class T> Callback_SonarServer_removeListenerPtr
newCallback_SonarServer_removeListener(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServer_removeListener<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_removeListener.
 */
template<class T> Callback_SonarServer_removeListenerPtr
newCallback_SonarServer_removeListener(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServer_removeListener<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::sonar::SonarServer::begin_removeListener.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServer_removeListener.
 */
template<class T, typename CT>
class Callback_SonarServer_removeListener : public Callback_SonarServer_removeListener_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_SonarServer_removeListener(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_removeListener.
 */
template<class T, typename CT> Callback_SonarServer_removeListenerPtr
newCallback_SonarServer_removeListener(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServer_removeListener<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_removeListener.
 */
template<class T, typename CT> Callback_SonarServer_removeListenerPtr
newCallback_SonarServer_removeListener(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServer_removeListener<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_removeListener.
 */
template<class T, typename CT> Callback_SonarServer_removeListenerPtr
newCallback_SonarServer_removeListener(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServer_removeListener<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_removeListener.
 */
template<class T, typename CT> Callback_SonarServer_removeListenerPtr
newCallback_SonarServer_removeListener(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServer_removeListener<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::sonar::SonarServer::begin_getStatuses.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServer_getStatuses.
 */
template<class T>
class CallbackNC_SonarServer_getStatuses : public Callback_SonarServer_getStatuses_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ServerStatusSeq&);

    CallbackNC_SonarServer_getStatuses(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SonarServerPrx proxy = SonarServerPrx::uncheckedCast(result->getProxy());
        ServerStatusSeq ret;
        try
        {
            ret = proxy->end_getStatuses(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_getStatuses.
 */
template<class T> Callback_SonarServer_getStatusesPtr
newCallback_SonarServer_getStatuses(const IceUtil::Handle<T>& instance, void (T::*cb)(const ServerStatusSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServer_getStatuses<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_getStatuses.
 */
template<class T> Callback_SonarServer_getStatusesPtr
newCallback_SonarServer_getStatuses(T* instance, void (T::*cb)(const ServerStatusSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServer_getStatuses<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::sonar::SonarServer::begin_getStatuses.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServer_getStatuses.
 */
template<class T, typename CT>
class Callback_SonarServer_getStatuses : public Callback_SonarServer_getStatuses_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ServerStatusSeq&, const CT&);

    Callback_SonarServer_getStatuses(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SonarServerPrx proxy = SonarServerPrx::uncheckedCast(result->getProxy());
        ServerStatusSeq ret;
        try
        {
            ret = proxy->end_getStatuses(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_getStatuses.
 */
template<class T, typename CT> Callback_SonarServer_getStatusesPtr
newCallback_SonarServer_getStatuses(const IceUtil::Handle<T>& instance, void (T::*cb)(const ServerStatusSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServer_getStatuses<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_getStatuses.
 */
template<class T, typename CT> Callback_SonarServer_getStatusesPtr
newCallback_SonarServer_getStatuses(T* instance, void (T::*cb)(const ServerStatusSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServer_getStatuses<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::sonar::SonarServer::begin_loadConfig.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServer_loadConfig.
 */
template<class T>
class CallbackNC_SonarServer_loadConfig : public Callback_SonarServer_loadConfig_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_SonarServer_loadConfig(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SonarServerPrx proxy = SonarServerPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_loadConfig(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_loadConfig.
 */
template<class T> Callback_SonarServer_loadConfigPtr
newCallback_SonarServer_loadConfig(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServer_loadConfig<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_loadConfig.
 */
template<class T> Callback_SonarServer_loadConfigPtr
newCallback_SonarServer_loadConfig(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SonarServer_loadConfig<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::sonar::SonarServer::begin_loadConfig.
 * Create a wrapper instance by calling ::sonar::newCallback_SonarServer_loadConfig.
 */
template<class T, typename CT>
class Callback_SonarServer_loadConfig : public Callback_SonarServer_loadConfig_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_SonarServer_loadConfig(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SonarServerPrx proxy = SonarServerPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_loadConfig(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_loadConfig.
 */
template<class T, typename CT> Callback_SonarServer_loadConfigPtr
newCallback_SonarServer_loadConfig(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServer_loadConfig<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::sonar::SonarServer::begin_loadConfig.
 */
template<class T, typename CT> Callback_SonarServer_loadConfigPtr
newCallback_SonarServer_loadConfig(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SonarServer_loadConfig<T, CT>(instance, cb, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
